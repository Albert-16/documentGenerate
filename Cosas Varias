using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using Dapper;

public async Task ActualizarEstadoEnvioBatchAsync(
    IEnumerable<(string IdDocumento, int Estado)> items,
    int chunkSize = 200,
    int commandTimeout = 60)
{
    if (items == null)
    {
        _logger.Information("BatchUpdate: items viene null.");
        return;
    }

    // Limpieza + deduplicación por ID (se queda con el último estado)
    var lista = items
        .Where(x => !string.IsNullOrWhiteSpace(x.IdDocumento))
        .Select(x => (IdDocumento: x.IdDocumento.Trim(), x.Estado))
        .GroupBy(x => x.IdDocumento)
        .Select(g => g.Last())
        .ToList();

    if (lista.Count == 0)
    {
        _logger.Information("BatchUpdate: lista vacía.");
        return;
    }

    var now   = DateTime.Now;
    var fecha = now.ToString("yyyyMMdd"); // 8
    var hora  = now.ToString("HHmmss");   // 6

    if (_database.Connection.State != ConnectionState.Open)
        _database.Connect();

    _logger.Information("BatchUpdate: inicia. TotalUnicos={Total} ChunkSize={ChunkSize} Fecha={Fecha} Hora={Hora}",
        lista.Count, chunkSize, fecha, hora);

    for (int offset = 0; offset < lista.Count; offset += chunkSize)
    {
        var chunk = lista.Skip(offset).Take(chunkSize).ToList();

        // IMPORTANTE: IBM i a veces exige tipo en VALUES -> CAST
        // Y el provider OleDb se lleva mejor con CHAR fijo.
        var valuesSql = string.Join(",\n",
            chunk.Select(_ => "(CAST(? AS CHAR(100)), CAST(? AS SMALLINT))"));

        var sql = $@"
MERGE INTO EVERTECDTA.GCTDC09L1 T
USING (VALUES
{valuesSql}
) S (ID, ESTADO)
ON T.GCTDC09001 = S.ID
WHEN MATCHED THEN
  UPDATE SET
    T.GCTDC09014 = S.ESTADO,
    T.GCTDC09007 = CAST(? AS CHAR(8)),
    T.GCTDC09008 = CAST(? AS CHAR(6))
";

        var p = new DynamicParameters();

        // Parámetros por ORDEN (OleDb es posicional).
        // Pero Dapper necesita nombres únicos.
        for (int i = 0; i < chunk.Count; i++)
        {
            var id = chunk[i].IdDocumento;
            if (id.Length > 100) id = id.Substring(0, 100);

            // ID: CHAR(100)
            p.Add($"id{i}", id, dbType: DbType.AnsiStringFixedLength, size: 100);

            // Estado: SMALLINT (int16)
            p.Add($"st{i}", (short)chunk[i].Estado, dbType: DbType.Int16);
        }

        // Fecha / Hora
        p.Add("fecha", fecha, dbType: DbType.AnsiStringFixedLength, size: 8);
        p.Add("hora",  hora,  dbType: DbType.AnsiStringFixedLength, size: 6);

        // Logs de diagnóstico (útiles si vuelve a fallar)
        var qCount = sql.Count(c => c == '?');
        var pCount = p.ParameterNames.Count();
        _logger.Information("BatchUpdate: chunk {Ini}-{Fin} ?={QCount} Params={PCount}",
            offset + 1, offset + chunk.Count, qCount, pCount);

        var affected = await _database.Connection.ExecuteAsync(sql, p, commandTimeout: commandTimeout);

        _logger.Information("BatchUpdate: chunk {Ini}-{Fin} OK. Registros={Count}. Affected={Affected}",
            offset + 1, offset + chunk.Count, chunk.Count, affected);
    }

    _logger.Information("BatchUpdate: finaliza OK. TotalUnicos={Total}", lista.Count);
}
