using System;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Dapper;

public async Task ActualizarEstadoEnvioBatchAsync(
    IEnumerable<(string IdDocumento, int Estado)> items,
    int chunkSize = 200,
    int commandTimeout = 60)
{
    var runId = Guid.NewGuid().ToString("N");

    if (items == null)
    {
        _logger.Information("BatchUpdate[{RunId}]: items viene null. No se ejecuta.", runId);
        return;
    }

    // Limpieza + dedupe (se queda con el último estado por ID)
    var lista = items
        .Where(x => !string.IsNullOrWhiteSpace(x.IdDocumento))
        .Select(x => (IdDocumento: x.IdDocumento.Trim(), x.Estado))
        .GroupBy(x => x.IdDocumento)
        .Select(g => g.Last())
        .ToList();

    if (lista.Count == 0)
    {
        _logger.Information("BatchUpdate[{RunId}]: lista vacía. No se ejecuta.", runId);
        return;
    }

    var now   = DateTime.Now;
    var fecha = now.ToString("yyyyMMdd"); // CHAR(8)
    var hora  = now.ToString("HHmmss");   // CHAR(6)

    if (_database.Connection.State != ConnectionState.Open)
        _database.Connect();

    var totalSw = Stopwatch.StartNew();

    _logger.Information(
        "BatchUpdate[{RunId}]: inicia. TotalUnicos={Total} ChunkSize={ChunkSize} Fecha={Fecha} Hora={Hora}",
        runId, lista.Count, chunkSize, fecha, hora);

    try
    {
        for (int offset = 0; offset < lista.Count; offset += chunkSize)
        {
            var chunk = lista.Skip(offset).Take(chunkSize).ToList();
            var firstId = chunk.First().IdDocumento;
            var lastId  = chunk.Last().IdDocumento;

            // SQL: MERGE + VALUES con CAST (IBM i pide tipos)
            var valuesSql = string.Join(",\n",
                chunk.Select(_ => "(CAST(? AS CHAR(100)), CAST(? AS SMALLINT))"));

            var sql = $@"
MERGE INTO EVERTECDTA.GCTDC09L1 T
USING (VALUES
{valuesSql}
) S (ID, ESTADO)
ON T.GCTDC09001 = S.ID
WHEN MATCHED THEN
  UPDATE SET
    T.GCTDC09014 = S.ESTADO,
    T.GCTDC09007 = CAST(? AS CHAR(8)),
    T.GCTDC09008 = CAST(? AS CHAR(6))
";

            var p = new DynamicParameters();

            // Parámetros por orden (OleDb es posicional)
            for (int i = 0; i < chunk.Count; i++)
            {
                var id = chunk[i].IdDocumento;
                if (id.Length > 100) id = id.Substring(0, 100);

                p.Add($"id{i}", id, dbType: DbType.AnsiStringFixedLength, size: 100);
                p.Add($"st{i}", (short)chunk[i].Estado, dbType: DbType.Int16);
            }

            p.Add("fecha", fecha, dbType: DbType.AnsiStringFixedLength, size: 8);
            p.Add("hora",  hora,  dbType: DbType.AnsiStringFixedLength, size: 6);

            // Logs “útiles” por chunk
            _logger.Information(
                "BatchUpdate[{RunId}]: chunk {Ini}-{Fin} IDs '{First}'..'{Last}' Count={Count}",
                runId, offset + 1, offset + chunk.Count, firstId, lastId, chunk.Count);

            var chunkSw = Stopwatch.StartNew();

            try
            {
                // Diagnóstico (solo útil si falla, pero lo dejamos por ahora)
                var qCount = sql.Count(c => c == '?');
                var pCount = p.ParameterNames.Count();
                _logger.Information("BatchUpdate[{RunId}]: chunk {Ini}-{Fin} ?={QCount} Params={PCount}",
                    runId, offset + 1, offset + chunk.Count, qCount, pCount);

                var affected = await _database.Connection.ExecuteAsync(sql, p, commandTimeout: commandTimeout);

                chunkSw.Stop();

                _logger.Information(
                    "BatchUpdate[{RunId}]: chunk {Ini}-{Fin} OK. Affected={Affected} Ms={Ms}",
                    runId, offset + 1, offset + chunk.Count, affected, chunkSw.ElapsedMilliseconds);
            }
            catch (Exception exChunk)
            {
                chunkSw.Stop();

                // Preview de IDs (limitado)
                var idsPreview = string.Join(", ", chunk.Take(10).Select(x => x.IdDocumento));

                var qCount = sql.Count(c => c == '?');
                var pCount = p.ParameterNames.Count();

                _logger.Information(
                    "BatchUpdate[{RunId}]: ERROR chunk {Ini}-{Fin}. ?={QCount} Params={PCount} IdsPreview=[{IdsPreview}] Ms={Ms} Error={Error}",
                    runId, offset + 1, offset + chunk.Count, qCount, pCount, idsPreview, chunkSw.ElapsedMilliseconds, exChunk.Message);

                throw;
            }
        }

        totalSw.Stop();
        _logger.Information("BatchUpdate[{RunId}]: finaliza OK. TotalUnicos={Total} TotalMs={Ms}",
            runId, lista.Count, totalSw.ElapsedMilliseconds);
    }
    catch (Exception ex)
    {
        totalSw.Stop();
        _logger.Information("BatchUpdate[{RunId}]: finaliza con ERROR. TotalUnicos={Total} TotalMs={Ms} Error={Error}",
            runId, lista.Count, totalSw.ElapsedMilliseconds, ex.Message);
        throw;
    }
}
```0
